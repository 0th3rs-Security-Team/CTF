# House of Lore

## 效果
控制指定地址内容

## 利用思想
smallbin的分配是取链表尾端分配，如果能篡改一个在smallbin链表中堆块的bk指针为我们设定的地址，即可在最后malloc时分配到指定地址

## 完整性检查
smallbin的分配是取出链表尾端堆块`victim`，取出后会有如下操作:

```c
bck = victim->bk;
bin->bk = bck;
bck->fd = bin;
```

由于`bck`是直接采用堆块里的数据，若堆块被篡改，则以上操作很有可能造成任意地址写，因此必须检查`bck`的完整性

```c
if (__glibc_unlikely (bck->fd != victim))
{
    errstr = "malloc(): smallbin double linked list corrupted";
    goto errout;
}
```

## 利用步骤
（1）创建`chunk 1`和`chunk 2`，`chunk 1`的大小要在small chunk范围内，假设为0x100，`chunk 2`用作栅栏，大小任意，目的是避免`chunk 1`在释放后与top chunk合并；

（2）在设定地址伪造一个堆块头`ret chunk`，并使其fd指针指向`chunk 1`；伪造一个辅助块`fake chunk`，使其fd指针指向`ret chunk`，且`ret chunk`的bk指针指向`fake chunk`。之所以要伪造一个辅助块，是为了在最后一次malloc操作时能成功获得`ret chunk`，而不触发完整性检查；

（3）free掉`chunk 1`，此时`chunk 1`在unsorted bin或fast bin里面，我们再申请一个large chunk，让`chunk 1`归位到small bin；

（4）利用堆漏洞（如溢出），修改`chunk 1`的bk指针为`ret chunk`；

（5）第一次malloc（大小要与对应small bin匹配，下同）得到`chunk 1`，第二次malloc得到`ret chunk`，任务完成。

## 利用条件
（1）由利用步骤（2）知，`chunk 1`, `ret chunk`和`fake chunk`地址必须已知，后两者容易满足，而`chunk 1`地址通常需要借助其他堆地址泄露方法获得

（2）`ret chunk`和`fake chunk`所在地址至少要能可控fd和bk指针

（3）程序存在漏洞，可修改small bin中`chunk 1`的bk指针

# House of Spirit

## 效果
延伸可控区域

## 利用思想
构造假的fast chunk，控制chunk size的大小能够覆盖原先不可控区域，释放该假块再申请回来即可获得原先不可控区域的控制权。常见于栈溢出不能覆盖到返回地址时。

## 完整性检查
（1）`IS_MMAPPED`位不能置1
```c
if (chunk_is_mmapped (p))
{
    [ ... ]

    munmap_chunk (p);
    return;
}
```

（2）chunk size必须在fast chunk范围内，且必须对齐
```c
if (__glibc_unlikely (size < MINSIZE || !aligned_OK (size)))
{
    errstr = "free(): invalid size";
    goto errout;
}

if ((unsigned long)(size) <= (unsigned long)(get_max_fast ()))
{
    [ ... ]
}
```

（3）2*SIZE_SZ < next chunk size < av->system_mem
```c
if (__builtin_expect (chunk_at_offset (p, size)->size <= 2 * SIZE_SZ, 0)
    || __builtin_expect (chunksize (chunk_at_offset (p, size))
                 >= av->system_mem, 0))
{
    [ ... ]

    errstr = "free(): invalid next size (fast)";
    goto errout;

    [ ... ]
}
```

## 利用步骤
（1）按完整性要求构造一个假fast chunk，其中`size`大小要能覆盖后面的不可控区域

（2）在假fast chunk的next chunk处，按完整性要求设置`size`（即next size）

（3）释放假fast chunk，并重新按`size`大小申请回来

## 利用条件
（1）必须存在这样的内存布局
```
+---------------------+
|                     |
|  Controlled Area 1  |
|                     |
+---------------------+
|                     |
|  Uncontrolled Area  |
|                     |
+---------------------+
|                     |
|  Controlled Area 2  |
|                     |
+---------------------+
```
在`Controlled Area 1`处布置假fast chunk，在`Controlled Area 2`处布置next chunk size。需要注意的是，我们可以通过调试，控制`Controlled Area 1`的chunk size来试图配对栈中现成的符合条件的next chunk size，若能够找到，则可不要求有`Controlled Area 2`

一般来说，这往往是一个栈结构，`Controlled Area 1`可能是子函数的一个可控局部变量，`Controlled Area 2`可能是父函数的一个可控局部变量，而`Uncontroled Area`通常是子函数的返回地址和父函数rbp寄存器，通过覆盖返回地址可以劫持控制流

（2）能控制堆指针指向`Controlled Area 1`处

一般需要结合其他方法完成这一步，比如先泄露`Controlled Area 1`的地址，再寻找覆写堆指针的机会

# House of Force

## 效果
控制指定地址内容

## 利用思想
`top chunk`切割时，给一个设定好的大小，使得切割后`top chunk`的头部位于指定地址，再次分配即可分配到指定地址

## 完整性检查
`top chunk`的`size`字段必须大于切割块的大小，一般需要通过溢出漏洞将它篡改为-1（即二进制全1）

```c
victim = av->top;
size = chunksize (victim);

// 如果在分割之后，其大小仍然满足 chunk 的最小大小，那么就可以直接进行分割
if ((unsigned long) (size) >= (unsigned long) (nb + MINSIZE))
  {
    // 切割并设置新top chunk
    remainder_size = size - nb;
    remainder = chunk_at_offset (victim, nb);
    av->top = remainder;
    set_head (victim, nb | PREV_INUSE |
              (av != &main_arena ? NON_MAIN_ARENA : 0));
    set_head (remainder, remainder_size | PREV_INUSE);

    check_malloced_chunk (av, victim, nb);
    void *p = chunk2mem (victim);
    alloc_perturb (p, bytes);
    return p;
  }
```

## 利用步骤

（1）分配任意大小（只要没大到需要mmap就行）的堆块

（2）通过溢出漏洞，修改`top chunk`的`size`为-1

（3）假设指定地址为`target`，则再分配一个`target - top - 4*SIZE_SZ`大小的堆块，如图
```
+---------------------+ <-- top
|  top chunk header   |
|---------------------|          -------
|                     |             ^
|     top chunk       |             |
|                     |             |
|                     |     target-top-4*SIZE_SZ
|                     |             |
|                     |             |
|                     |             |
         ...                        v
+---------------------+          -------
|    target header    |
|---------------------| <-- target
|                     |
|       target        |
|                     |
+---------------------+
```

（4）再分配一个堆块，即可得到指定地址

## 利用条件

* 分配的堆块大小没有限制（不过要特别注意整数溢出的情形，即输入的大小是有符号整数，但却没有做下界检查）

* 存在溢出漏洞可覆写`top chunk`头部的`size`字段

## 副作用

top chunk切割完后，由于此时新的`top chunk`在指定地址附近，因此在设置新的`top chunk`头部时，会修改指定地址周围的数据，同样，在随后的malloc也会在设置堆头时修改指定地址周围的数据。若是这些数据很关键，有可能会使程序运行逻辑错误，可能会导致利用不成功

# House of Einherjar

## 效果
用两种方式可以达到不同的效果：

* 激进的方式：控制指定地址内容

* 稳健的方式：形成重叠块（即有两个堆指针指向同一块区域，若通过其中一个指针将这块区域释放掉，我们还能通过另一个指针控制这块区域，造成Use-After-Free）

## 利用思想
通过`Null-byte Off-by-one`漏洞，抹掉下一个堆块的`INUSE`位，释放下一个堆块，系统误以为前一个堆块被释放，产生合并操作，再分配回来就出现了重叠块。更激进的方式可以控制下一堆块的`prev_size`，造成任意地址合并，再分配回来就可以控制指定地址内容

## 完整性检查
合并非`top chunk`块会产生unlink操作，因此unlink的条件必须要满足

（1）被unlink块的`fd`, `bk`, `fd_nextsize`, `bk_nextsize`指针的完整性
```c
if (__builtin_expect (FD->bk != P || BK->fd != P, 0))             \
      malloc_printerr (check_action, "corrupted double-linked list", P, AV);
```
```c
if (__builtin_expect (P->fd_nextsize->bk_nextsize != P, 0)        \
        || __builtin_expect (P->bk_nextsize->fd_nextsize != P, 0))    \
          malloc_printerr (check_action,                      \
                   "corrupted double-linked list (not small)",    \
                   P, AV);
```

（2）被unlink块的`size`字段的完整性
```c
if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))      \
      malloc_printerr (check_action, "corrupted size vs. prev_size", P, AV);
```
这要求被unlink块的`size`字段和下一个块的`prev_size`字段都要设计好

除了unlink条件，unsorted bin条件也要关注，特别是激进的方式通常会在这里出问题。unsorted bin中`size`必须在`2 * SIZE_SZ`到`av->system_mem`（即128K）范围内
```c
while ((victim = unsorted_chunks (av)->bk) != unsorted_chunks (av))
{
    bck = victim->bk;
    if (__builtin_expect (victim->size <= 2 * SIZE_SZ, 0)
        || __builtin_expect (victim->size > av->system_mem, 0))
    malloc_printerr (check_action, "malloc(): memory corruption",
                    chunk2mem (victim), av);
    [ ... ]
}
```

## 利用步骤（稳健的方式）

（1）构造一个大小为`sz`（`sz`需饱和，即`sz+SIZE_SZ`要关于`2*SIZE_SZ`对齐）的堆块`chunk 1`，并设置`fd`, `bk`, `fd_nextsize`, `bk_nextsize`指针指向自己（`sz`尽可能在smallbin范围内，这样可以不用设置`fd_nextsize`, `bk_nextsize`）

（2）构造大小为`0x100 - SIZE_SZ`的堆块`chunk 2`

（3）在`chunk 1`中通过`Null-byte Off-by-one`将`chunk 2`中`size`字段的`0x101`变成`0x100`，让系统误以为`chunk 1`已经释放，同时通过`chunk 1`设置`chunk 2`的`prev_size`字段为`sz+SIZE_SZ`

（4）释放掉`chunk 2`，此时会触发合并操作，并将合并后的结果送入unsorted bin

（5）申请大小为`0x100 + sz`的堆块`chunk 3`，此时`chunk 3`和`chunk 1`指向相同的位置，且`chunk 3`完全覆盖`chunk 1`的范围，形成重叠块

## 利用步骤（激进的方式）

（1）构造一个大小为`sz`（需饱和）的堆块`chunk 1`

（2）构造大小为`0x100 - SIZE_SZ`的堆块`chunk 2`

（3）在指定地址`addr`处构造一个`fake chunk`，将`fd`, `bk`, `fd_nextsize`, `bk_nextsize`指针指向`addr`，并将`size`字段设置为`chunk 2 - addr`

（4）在`chunk 1`中通过`Null-byte Off-by-one`将`chunk 2`中`size`字段的`0x101`变成`0x100`，让系统误以为`fake chunk`已经释放，同时通过`chunk 1`设置`chunk 2`的`prev_size`字段为`chunk 2 - addr`

（5）释放掉`chunk 2`，此时`chunk 2`会触发针对`fake chunk`的合并操作，若`chunk 2`还紧邻`top chunk`，则还会与`top chunk`合并，并设置新的`top chunk`地址为`addr`

（6）申请一个适当大小的`chunk 3`，`chunk 3`位于`addr`，通过操作`chunk 3`即可控制指定地址`addr`的内容

## 利用条件（稳健的方式）

（1）存在`Null-byte Off-by-one`漏洞

（2）`chunk 1`地址已知，即需要事先泄露堆地址

## 利用条件（激进的方式）
（1）存在`Null-byte Off-by-one`漏洞

（2）`addr`地址处至少要能控制`size`, `fd`, `bk`, `fd_nextsize`, `bk_nextsize`

（3）通常采用激进的方式，`fake chunk`的`size`将远超`av->system_mem`大小，若合并后放入unsorted bin，则分配回来的时候会触发unsorted bin的完整性检查，因此最好是将`chunk 2`与`top chunk`紧邻，这样`chunk 2`释放后将直接跟`top chunk`合并，从而避免放入unsorted bin。若是`chunk 2`与`top chunk`不紧邻，则要求合并后要具备重新改回`fake chunk`的`size`字段的能力

## 副作用
若合并后的堆块大于`FASTBIN_CONSOLIDATION_THRESHOLD`（默认64K），会导致释放的`fast chunk`会跟前后紧邻释放的`fast chunk`强制合并。采用激进的方式通常会满足这个条件，需要留心
```c
if ((unsigned long)(size) >= FASTBIN_CONSOLIDATION_THRESHOLD) {
    if (have_fastchunks(av))
        malloc_consolidate(av);
    [ ... ]
}
```

# House of Orange

## 效果

获得shell

## 利用思想

在程序不提供`free`函数的情况下，利用`top chunk`的延伸获得一个释放块，并伪造_IO_FILE结构劫持函数指针

## 预备知识

在`libc.so`中有一个全局指针`_IO_list_all`，指向一个`_IO_FILE_plus`类型的结构，结构声明如下：
```c
struct _IO_FILE_plus                //64位程序偏移 (32位程序偏移)
{
  _IO_FILE file;                    //+0x00 (+0x00)
  const struct _IO_jump_t *vtable;  //+0xd8 (+0x94)
};
```
`_IO_FILE`是一个描述文件的结构，通过`_chain`成员构成一个链表：
```c
struct _IO_FILE {                   //64位程序偏移 (32位程序偏移)
  int _flags;
  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;             //+0x20 (+0x10)
  char* _IO_write_ptr;              //+0x28 (+0x14)
  char* _IO_write_end;
  char* _IO_buf_base;               //+0x38 (+0x1c)
  char* _IO_buf_end;
  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;
  struct _IO_marker *_markers;
  struct _IO_FILE *_chain;          //+0x68 (+0x34)
  int _fileno;
  int _blksize;
  int _flags2;
  _IO_off_t _old_offset;
  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];
  _IO_lock_t *_lock;
  _IO_off64_t _offset;
  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;
  size_t __pad5;
  int _mode;                        //+0xc0 (+0x68)
  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
};
```
`_IO_jump_t`是一个函数指针数组类型，根据该类型实例化的指针`vtable`指向了保存一系列涉及I/O操作的函数指针数组，默认指向`_IO_file_jumps`，很多高层的I/O接口最终都会调用到它们。
```c
struct _IO_jump_t
{
    JUMP_FIELD(size_t, __dummy);
    JUMP_FIELD(size_t, __dummy2);
    JUMP_FIELD(_IO_finish_t, __finish);
    JUMP_FIELD(_IO_overflow_t, __overflow);
    JUMP_FIELD(_IO_underflow_t, __underflow);
    JUMP_FIELD(_IO_underflow_t, __uflow);
    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);
    JUMP_FIELD(_IO_xsputn_t, __xsputn);
    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);
    JUMP_FIELD(_IO_seekoff_t, __seekoff);
    JUMP_FIELD(_IO_seekpos_t, __seekpos);
    JUMP_FIELD(_IO_setbuf_t, __setbuf);
    JUMP_FIELD(_IO_sync_t, __sync);
    JUMP_FIELD(_IO_doallocate_t, __doallocate);
    JUMP_FIELD(_IO_read_t, __read);
    JUMP_FIELD(_IO_write_t, __write);
    JUMP_FIELD(_IO_seek_t, __seek);
    JUMP_FIELD(_IO_close_t, __close);
    JUMP_FIELD(_IO_stat_t, __stat);
    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);
    JUMP_FIELD(_IO_imbue_t, __imbue);
};
```
而堆操作中，一旦不符合某些完整性要求crash掉了，最后会调用`_IO_OVERFLOW`函数指针，也就是`vtable[3]`。

在`libc.so`的`__libc_IO_vtables`段中也有另一个涉及字符串I/O操作的`_IO_jump_t`类型的函数指针数组`_IO_str_jumps`
```c
const struct _IO_jump_t _IO_str_jumps libio_vtable =
{
  JUMP_INIT_DUMMY,
  JUMP_INIT(finish, _IO_str_finish),
  JUMP_INIT(overflow, _IO_str_overflow),
  JUMP_INIT(underflow, _IO_str_underflow),
  JUMP_INIT(uflow, _IO_default_uflow),
  JUMP_INIT(pbackfail, _IO_str_pbackfail),
  JUMP_INIT(xsputn, _IO_default_xsputn),
  JUMP_INIT(xsgetn, _IO_default_xsgetn),
  JUMP_INIT(seekoff, _IO_str_seekoff),
  JUMP_INIT(seekpos, _IO_default_seekpos),
  JUMP_INIT(setbuf, _IO_default_setbuf),
  JUMP_INIT(sync, _IO_default_sync),
  JUMP_INIT(doallocate, _IO_default_doallocate),
  JUMP_INIT(read, _IO_default_read),
  JUMP_INIT(write, _IO_default_write),
  JUMP_INIT(seek, _IO_default_seek),
  JUMP_INIT(close, _IO_default_close),
  JUMP_INIT(stat, _IO_default_stat),
  JUMP_INIT(showmanyc, _IO_default_showmanyc),
  JUMP_INIT(imbue, _IO_default_imbue)
};
```

它也对应着一个文件描述结构，类型为`_IO_strfile_`，实质上只是在`_IO_FILE_plus`的基础上补充了两个函数指针成员
```c
typedef struct _IO_strfile_             //64位程序偏移 (32位程序偏移)
{
  struct _IO_streambuf _sbf;            //与_IO_FILE_plus完全同构
  struct _IO_str_fields {
    _IO_alloc_type _allocate_buffer;    //+0xe0 (+0x98)
    _IO_free_type _free_buffer;         //+0xe8 (+0x9c)
  } _s;
} _IO_strfile;
```


## 完整性检查

（1）向系统申请延伸`top chunk`时

* 必须保证申请的大小小于0x21000（否则会调用mmap）
* `top chunksize`要大于等于`MINSIZE`，**且`av->top+chunksize`必须关于页对齐（0x1000整数倍）**
* `PREV_INUSE`必须置1

```c
if (av == NULL
    || ((unsigned long) (nb) >= (unsigned long) (mp_.mmap_threshold)
    && (mp_.n_mmaps < mp_.n_mmaps_max)))
{
    [ ... ]

    mm = (char *) (MMAP (0, size, PROT_READ | PROT_WRITE, 0));

    [ ... ]
}

old_top = av->top;
old_size = chunksize (old_top);
old_end = (char *) (chunk_at_offset (old_top, old_size));

assert ((old_top == initial_top (av) && old_size == 0) ||
        ((unsigned long) (old_size) >= MINSIZE &&
        prev_inuse (old_top) &&
        ((unsigned long) old_end & (pagesize - 1)) == 0));
```

（2）在`genops.c`中对`_IO_FILE`结构的某些成员有完整性约束，只有约束成立才会执行`_IO_OVERFLOW`函数指针
```c
if (((fp->_mode <= 0 && fp->_IO_write_ptr > fp->_IO_write_base))
	&& _IO_OVERFLOW (fp, EOF) == EOF)
        result = EOF;
```

（3）调用`_IO_str_finish`函数指针时，只有约束成立才会执行`(((_IO_strfile *) fp)->_s._free_buffer) (fp->_IO_buf_base)`，其中`_IO_USER_BUF`的宏值为1
```c
void _IO_str_finish (_IO_FILE *fp, int dummy)
{
  if (fp->_IO_buf_base && !(fp->_flags & _IO_USER_BUF))
    (((_IO_strfile *) fp)->_s._free_buffer) (fp->_IO_buf_base);
  fp->_IO_buf_base = NULL;

  _IO_default_finish (fp, 0);
}
```

（4）【glibc >= 2.24有效】vtable指针指向的地址必须在`__libc_IO_vtables`段内
```c
static inline const struct _IO_jump_t *
IO_validate_vtable (const struct _IO_jump_t *vtable)
{
  uintptr_t section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;
  const char *ptr = (const char *) vtable;
  uintptr_t offset = ptr - __start___libc_IO_vtables;
  if (__glibc_unlikely (offset >= section_length))
    _IO_vtable_check ();    // 直接crash
  return vtable;
}
```

## 利用步骤 (glibc < 2.24)

以64位为例：

（1）**申请大小为0x400-0x10的堆块`chunk 1`，并通过溢出修改`top chunksize`为0xc01**（数字可以灵活处理，只要满足`av->top+chunksize`关于页对齐等完整性条件即可）；

（2）**申请大小为0x1000的堆块**（数字可灵活处理），由于申请的大小大于0xc00，因此`top chunk`会紧邻原有的`old top`进行延伸。申请的这个堆块将直接在新的`top chunk`上进行分配，而大小为0xc00的`old top`会释放进`unsorted bin`中；

（3）**通过`chunk 1`溢出，修改`old top`的`bk`指针为`&_IO_list_all - 0x10`**。这样做的目的是，在进行`unsorted bin`遍历操作时，`bck->fd = unsorted_chunks (av)`等同于`(&_IO_list_all - 0x10)->fd = &main_arena + 88`，即`_IO_list_all = &main_arena + 88`，从而改写`_IO_list_all`全局指针；

（4）`&main_arena + 88`此时为伪造的_IO_FILE_plus结构的首地址，由于`main_arena`相关区域不可控，因此我们考虑改写结构成员`_chain`指针到可控区域，并在可控区域伪造`_IO_FILE`结构的关键成员。`_chain`在偏移`+0x68`处，即`&main_arena + 88 + 0x68`地址处，该地址对应`smallbin 0x60`的`bk`指针。**通过`chunk 1`溢出，修改`old top chunksize`为`0x61`**，则通过分配一个大小不为0x60的堆块，`old top`会从`unsorted bin`放入`smallbin 0x60`，顺带着会改写`bk`指针指向`old top`；

（5）伪造`_IO_FILE`结构和`/bin/sh\0`字符串。根据完整性条件（2）可知，`_mode`，`_IO_write_ptr`，`_IO_write_base`三个成员会被检查，且`_IO_OVERFLOW`的参数就是`old top`。因此可**通过溢出赋值`*(old_top+0xc0)=0`，`*(old_top+0x20)=2`，`*(old_top+0x28)=3`，`*(old_top)="/bin/sh\0"`**；

（6）在空闲的可控区域伪造`_IO_jump_t`结构，并改写`vtable`指向伪造的结构。`old_top+0x60`处较为空闲，而`vtable`偏移为`+0xd8`，因此可**通过溢出赋值`*(old_top+0xd8)=old_top+0x60`**。而`vtable[3]`对应着`_IO_OVERFLOW`函数指针，因此**通过溢出赋值`*(old_top+0x60+0x18)=system地址`**；

（7）**申请大小为0x10的堆块**，将会触发（3）到（7）步的所有效果。首先系统会从`unsorted bin`中寻找合适的分配块，第一个块为`old top`，取出该块时对应着第（3）步的操作；由于其`chunksize`为0x60，不满足要求，因此`old top`被放入`smallbin 0x60`中，改写了对应`bin`的`bk`指针，对应着第（4）步操作；第二个`unsorted bin`块对应着`old_top->bk`，即`&_IO_list_all - 0x10`，而这个块的`chunksize`为0，不符合`unsorted chunk`的完整性要求`2 * SIZE_SZ < chunksize <= av->system_mem`，因此会crash，最终会执行`_IO_OVERFLOW (fp, EOF)`，由于`_IO_OVERFLOW`已被替换为`system`，`fp`指向字符串`/bin/sh\0`，因此shell获得。

## 利用步骤 (glibc < 2.26)
基本思路：glibc 2.24以上版本有完整性（4）的约束，使得攻击者很难劫持`vtable`指针到可控区域，从而直接伪造函数指针数组。但可以劫持`vtable`指针到`_IO_str_jumps`，它的地址是位于`__libc_IO_vtables`段内的，不会破坏完整性。基本思路是控制`vtable`值为`&_IO_str_jumps - 0x10`，这样`vtable[3]`对应的`_IO_OVERFLOW`正好与`_IO_str_jumps`函数指针数组的`_IO_str_finish`重合。

（1）-（4）步骤与前面的一致；

（5）**通过溢出赋值`*(old_top+0xc0)=0`，`*(old_top+0x20)=2`，`*(old_top+0x28)=3`**，目的是伪造`_IO_FILE`结构的`_mode`，`_IO_write_ptr`，`_IO_write_base`三个成员，通过完整性条件（2）的检查；

（6）**通过溢出赋值`*(old_top+0xe8)=system地址`，`*(old_top+0x38)=libc中"/bin/sh"的地址`，`*(old_top)=0`**，目的是伪造`_IO_str_files._s._free_buffer`以及`_IO_FILE`结构的`_IO_buf_base`，`_flags`成员，既劫持函数指针，又符合完整性检查（3）。**若`one_gadget`条件允许，也可以赋值`*(old_top+0xe8)=one_gadget地址`，此时`*(old_top+0x38)`可以随意设置，但根据完整性检查（3）不得设置为`NULL`**；

（7）**通过溢出赋值`*(old_top+0xd8)=&_IO_str_jumps-0x10`**，目的是改写`vtable`使得`vtable[3]`与`_IO_str_jumps`函数指针数组的`_IO_str_finish`重合；

（8）**申请大小为0x10的堆块**触发所有动作。

## 利用条件

（1）没提供`free`函数（当然提供了`free`函数也可以用，但那样就没必要`House of Orange`了）；

（2）“glibc < 2.24 利用步骤“第（5）步中是在堆中伪造的`_IO_jump_t`结构，因此需要知道堆基址来改写`vtable`。但若是能在已知地址伪造`vtable[3]`也可不需要堆基址，例如“glibc < 2.26 利用步骤“所述方法可不需要堆基址；

（3）需要知道libc基址来获得`system`函数地址；

（4）存在溢出，且溢出范围比较大。

## 说明

glibc >= 2.26的版本crash将不再调用_IO_flush_all_lockp，故该利用方法失效。

`House of Orange`本质是一种结合利用，可以认为是get free chunk by extending top + unsorted bin attack + FSOP三者的结合利用，后半部分涉及`_IO_*`结构的操作也是`FSOP`的利用方式。