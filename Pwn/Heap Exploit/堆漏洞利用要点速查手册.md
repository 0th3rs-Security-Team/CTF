# House of Lore

## 效果
控制指定地址内容

## 利用思想
smallbin的分配是取链表尾端分配，如果能篡改一个在smallbin链表中堆块的bk指针为我们设定的地址，即可在最后malloc时分配到指定地址

## 完整性检查
smallbin的分配是取出链表尾端堆块`victim`，取出后会有如下操作:

```c
bck = victim->bk;
bin->bk = bck;
bck->fd = bin;
```

由于`bck`是直接采用堆块里的数据，若堆块被篡改，则以上操作很有可能造成任意地址写，因此必须检查`bck`的完整性

```c
if (__glibc_unlikely (bck->fd != victim))
{
    errstr = "malloc(): smallbin double linked list corrupted";
    goto errout;
}
```

## 利用步骤
（1）创建`chunk 1`和`chunk 2`，`chunk 1`的大小要在small chunk范围内，假设为0x100，`chunk 2`用作栅栏，大小任意，目的是避免`chunk 1`在释放后与top chunk合并；

（2）在设定地址伪造一个堆块头`ret chunk`，并使其fd指针指向`chunk 1`；伪造一个辅助块`fake chunk`，使其fd指针指向`ret chunk`，且`ret chunk`的bk指针指向`fake chunk`。之所以要伪造一个辅助块，是为了在最后一次malloc操作时能成功获得`ret chunk`，而不触发完整性检查；

（3）free掉`chunk 1`，此时`chunk 1`在unsorted bin或fast bin里面，我们再申请一个large chunk，让`chunk 1`归位到small bin；

（4）利用堆漏洞（如溢出），修改`chunk 1`的bk指针为`ret chunk`；

（5）第一次malloc（大小要与对应small bin匹配，下同）得到`chunk 1`，第二次malloc得到`ret chunk`，任务完成。

## 利用条件
（1）由利用步骤（2）知，`chunk 1`, `ret chunk`和`fake chunk`地址必须已知，后两者容易满足，而`chunk 1`地址通常需要借助其他堆地址泄露方法获得

（2）`ret chunk`和`fake chunk`所在地址至少要能可控fd和bk指针

（3）程序存在漏洞，可修改small bin中`chunk 1`的bk指针

# House of Spirit

## 效果
延伸可控区域

## 利用思想
构造假的fast chunk，控制chunk size的大小能够覆盖原先不可控区域，释放该假块再申请回来即可获得原先不可控区域的控制权。常见于栈溢出不能覆盖到返回地址时。

## 完整性检查
（1）`IS_MMAPPED`位不能置1
```c
if (chunk_is_mmapped (p))
{
    [ ... ]

    munmap_chunk (p);
    return;
}
```

（2）chunk size必须在fast chunk范围内，且必须对齐
```c
if (__glibc_unlikely (size < MINSIZE || !aligned_OK (size)))
{
    errstr = "free(): invalid size";
    goto errout;
}

if ((unsigned long)(size) <= (unsigned long)(get_max_fast ()))
{
    [ ... ]
}
```

（3）2*SIZE_SZ < next chunk size < av->system_mem
```c
if (__builtin_expect (chunk_at_offset (p, size)->size <= 2 * SIZE_SZ, 0)
    || __builtin_expect (chunksize (chunk_at_offset (p, size))
                 >= av->system_mem, 0))
{
    [ ... ]

    errstr = "free(): invalid next size (fast)";
    goto errout;

    [ ... ]
}
```

## 利用步骤
（1）按完整性要求构造一个假fast chunk，其中`size`大小要能覆盖后面的不可控区域

（2）在假fast chunk的next chunk处，按完整性要求设置`size`（即next size）

（3）释放假fast chunk，并重新按`size`大小申请回来

## 利用条件
（1）必须存在这样的内存布局
```
+---------------------+
|                     |
|  Controlled Area 1  |
|                     |
+---------------------+
|                     |
|  Uncontrolled Area  |
|                     |
+---------------------+
|                     |
|  Controlled Area 2  |
|                     |
+---------------------+
```
在`Controlled Area 1`处布置假fast chunk，在`Controlled Area 2`处布置next chunk size。需要注意的是，我们可以通过调试，控制`Controlled Area 1`的chunk size来试图配对栈中现成的符合条件的next chunk size，若能够找到，则可不要求有`Controlled Area 2`

一般来说，这往往是一个栈结构，`Controlled Area 1`可能是子函数的一个可控局部变量，`Controlled Area 2`可能是父函数的一个可控局部变量，而`Uncontroled Area`通常是子函数的返回地址和父函数rbp寄存器，通过覆盖返回地址可以劫持控制流

（2）能控制堆指针指向`Controlled Area 1`处

一般需要结合其他方法完成这一步，比如先泄露`Controlled Area 1`的地址，再寻找覆写堆指针的机会

# House of Force

## 效果
控制指定地址内容

## 利用思想
`top chunk`切割时，给一个设定好的大小，使得切割后`top chunk`的头部位于指定地址，再次分配即可分配到指定地址

## 完整性检查
`top chunk`的`size`字段必须大于切割块的大小，一般需要通过溢出漏洞将它篡改为-1（即二进制全1）

```c
victim = av->top;
size = chunksize (victim);

// 如果在分割之后，其大小仍然满足 chunk 的最小大小，那么就可以直接进行分割
if ((unsigned long) (size) >= (unsigned long) (nb + MINSIZE))
  {
    // 切割并设置新top chunk
    remainder_size = size - nb;
    remainder = chunk_at_offset (victim, nb);
    av->top = remainder;
    set_head (victim, nb | PREV_INUSE |
              (av != &main_arena ? NON_MAIN_ARENA : 0));
    set_head (remainder, remainder_size | PREV_INUSE);

    check_malloced_chunk (av, victim, nb);
    void *p = chunk2mem (victim);
    alloc_perturb (p, bytes);
    return p;
  }
```

## 利用步骤

（1）分配任意大小（只要没大到需要mmap就行）的堆块

（2）通过溢出漏洞，修改`top chunk`的`size`为-1

（3）假设指定地址为`target`，则再分配一个`target - top - 4*SIZE_SZ`大小的堆块，如图
```
+---------------------+ <-- top
|  top chunk header   |
|---------------------|          -------
|                     |             ^
|     top chunk       |             |
|                     |             |
|                     |     target-top-4*SIZE_SZ
|                     |             |
|                     |             |
|                     |             |
         ...                        v
+---------------------+          -------
|    target header    |
|---------------------| <-- target
|                     |
|       target        |
|                     |
+---------------------+
```

（4）再分配一个堆块，即可得到指定地址

## 利用条件

* 分配的堆块大小没有限制（不过要特别注意整数溢出的情形，即输入的大小是有符号整数，但却没有做下界检查）

* 存在溢出漏洞可覆写`top chunk`头部的`size`字段

## 副作用

top chunk切割完后，由于此时新的`top chunk`在指定地址附近，因此在设置新的`top chunk`头部时，会修改指定地址周围的数据，同样，在随后的malloc也会在设置堆头时修改指定地址周围的数据。若是这些数据很关键，有可能会使程序运行逻辑错误，可能会导致利用不成功

# House of Einherjar

## 效果
用两种方式可以达到不同的效果：

* 激进的方式：控制指定地址内容

* 稳健的方式：形成重叠块（即有两个堆指针指向同一块区域，若通过其中一个指针将这块区域释放掉，我们还能通过另一个指针控制这块区域，造成Use-After-Free）

## 利用思想
通过`Null-byte Off-by-one`漏洞，抹掉下一个堆块的`INUSE`位，释放下一个堆块，系统误以为前一个堆块被释放，产生合并操作，再分配回来就出现了重叠块。更激进的方式可以控制下一堆块的`prev_size`，造成任意地址合并，再分配回来就可以控制指定地址内容

## 完整性检查
合并非`top chunk`块会产生unlink操作，因此unlink的条件必须要满足

（1）被unlink块的`fd`, `bk`, `fd_nextsize`, `bk_nextsize`指针的完整性
```c
if (__builtin_expect (FD->bk != P || BK->fd != P, 0))             \
      malloc_printerr (check_action, "corrupted double-linked list", P, AV);
```
```c
if (__builtin_expect (P->fd_nextsize->bk_nextsize != P, 0)        \
        || __builtin_expect (P->bk_nextsize->fd_nextsize != P, 0))    \
          malloc_printerr (check_action,                      \
                   "corrupted double-linked list (not small)",    \
                   P, AV);
```

（2）被unlink块的`size`字段的完整性
```c
if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))      \
      malloc_printerr (check_action, "corrupted size vs. prev_size", P, AV);
```
这要求被unlink块的`size`字段和下一个块的`prev_size`字段都要设计好

除了unlink条件，unsorted bin条件也要关注，特别是激进的方式通常会在这里出问题。unsorted bin中`size`必须在`2 * SIZE_SZ`到`av->system_mem`（即128K）范围内
```c
while ((victim = unsorted_chunks (av)->bk) != unsorted_chunks (av))
{
    bck = victim->bk;
    if (__builtin_expect (victim->size <= 2 * SIZE_SZ, 0)
        || __builtin_expect (victim->size > av->system_mem, 0))
    malloc_printerr (check_action, "malloc(): memory corruption",
                    chunk2mem (victim), av);
    [ ... ]
}
```

## 利用步骤（稳健的方式）

（1）构造一个大小为`sz`（`sz`需饱和，即`sz+SIZE_SZ`要关于`2*SIZE_SZ`对齐）的堆块`chunk 1`，并设置`fd`, `bk`, `fd_nextsize`, `bk_nextsize`指针指向自己（`sz`尽可能在smallbin范围内，这样可以不用设置`fd_nextsize`, `bk_nextsize`）

（2）构造大小为`0x100 - SIZE_SZ`的堆块`chunk 2`

（3）在`chunk 1`中通过`Null-byte Off-by-one`将`chunk 2`中`size`字段的`0x101`变成`0x100`，让系统误以为`chunk 1`已经释放，同时通过`chunk 1`设置`chunk 2`的`prev_size`字段为`sz+SIZE_SZ`

（4）释放掉`chunk 2`，此时会触发合并操作，并将合并后的结果送入unsorted bin

（5）申请大小为`0x100 + sz`的堆块`chunk 3`，此时`chunk 3`和`chunk 1`指向相同的位置，且`chunk 3`完全覆盖`chunk 1`的范围，形成重叠块

## 利用步骤（激进的方式）

（1）构造一个大小为`sz`（需饱和）的堆块`chunk 1`

（2）构造大小为`0x100 - SIZE_SZ`的堆块`chunk 2`

（3）在指定地址`addr`处构造一个`fake chunk`，将`fd`, `bk`, `fd_nextsize`, `bk_nextsize`指针指向`addr`，并将`size`字段设置为`chunk 2 - addr`

（4）在`chunk 1`中通过`Null-byte Off-by-one`将`chunk 2`中`size`字段的`0x101`变成`0x100`，让系统误以为`fake chunk`已经释放，同时通过`chunk 1`设置`chunk 2`的`prev_size`字段为`chunk 2 - addr`

（5）释放掉`chunk 2`，此时`chunk 2`会触发针对`fake chunk`的合并操作，若`chunk 2`还紧邻`top chunk`，则还会与`top chunk`合并，并设置新的`top chunk`地址为`addr`

（6）申请一个适当大小的`chunk 3`，`chunk 3`位于`addr`，通过操作`chunk 3`即可控制指定地址`addr`的内容

## 利用条件（稳健的方式）

（1）存在`Null-byte Off-by-one`漏洞

（2）`chunk 1`地址已知，即需要事先泄露堆地址

## 利用条件（激进的方式）
（1）存在`Null-byte Off-by-one`漏洞

（2）`addr`地址处至少要能控制`size`, `fd`, `bk`, `fd_nextsize`, `bk_nextsize`

（3）通常采用激进的方式，`fake chunk`的`size`将远超`av->system_mem`大小，若合并后放入unsorted bin，则分配回来的时候会触发unsorted bin的完整性检查，因此最好是将`chunk 2`与`top chunk`紧邻，这样`chunk 2`释放后将直接跟`top chunk`合并，从而避免放入unsorted bin。若是`chunk 2`与`top chunk`不紧邻，则要求合并后要具备重新改回`fake chunk`的`size`字段的能力

## 副作用
若合并后的堆块大于`FASTBIN_CONSOLIDATION_THRESHOLD`（默认64K），会导致释放的`fast chunk`会跟前后紧邻释放的`fast chunk`强制合并。采用激进的方式通常会满足这个条件，需要留心
```c
if ((unsigned long)(size) >= FASTBIN_CONSOLIDATION_THRESHOLD) {
    if (have_fastchunks(av))
        malloc_consolidate(av);
    [ ... ]
}
```