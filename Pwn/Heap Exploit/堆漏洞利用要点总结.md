# House of Lore

## 效果
控制指定地址内容

## 利用思想
smallbin的分配是取链表尾端分配，如果能篡改一个在smallbin链表中堆块的bk指针为我们设定的地址，即可在最后malloc时分配到指定地址

## 完整性检查
smallbin的分配是取出链表尾端堆块`victim`，取出后会有如下操作:

```c
bck = victim->bk;
bin->bk = bck;
bck->fd = bin;
```

由于`bck`是直接采用堆块里的数据，若堆块被篡改，则以上操作很有可能造成任意地址写，因此必须检查`bck`的完整性

```c
if (__glibc_unlikely (bck->fd != victim))
{
    errstr = "malloc(): smallbin double linked list corrupted";
    goto errout;
}
```

## 利用步骤
（1）创建`chunk 1`和`chunk 2`，`chunk 1`的大小要在small chunk范围内，假设为0x100，`chunk 2`用作栅栏，大小任意，目的是避免`chunk 1`在释放后与top chunk合并；

（2）在设定地址伪造一个堆块头`ret chunk`，并使其fd指针指向`chunk 1`；伪造一个辅助块`fake chunk`，使其fd指针指向`ret chunk`，且`ret chunk`的bk指针指向`fake chunk`。之所以要伪造一个辅助块，是为了在最后一次malloc操作时能成功获得`ret chunk`，而不触发完整性检查；

（3）free掉`chunk 1`，此时`chunk 1`在unsorted bin或fast bin里面，我们再申请一个large chunk，让`chunk 1`归位到small bin；

（4）利用堆漏洞（如溢出），修改`chunk 1`的bk指针为`ret chunk`；

（5）第一次malloc（大小要与对应small bin匹配，下同）得到`chunk 1`，第二次malloc得到`ret chunk`，任务完成。

## 利用条件
* 由（2）知，`chunk 1`, `ret chunk`和`fake chunk`地址必须已知，后两者容易满足，而`chunk 1`地址通常需要借助其他堆地址泄露方法获得

* `ret chunk`和`fake chunk`所在地址至少要能可控fd和bk指针

* 程序存在漏洞，可修改small bin中`chunk 1`的bk指针

# House of Spirit

## 效果
延伸可控区域

## 利用思想
构造假的fast chunk，控制chunk size的大小能够覆盖原先不可控区域，释放该假块再申请回来即可获得原先不可控区域的控制权。常见于栈溢出不能覆盖到返回地址时。

## 完整性检查
（1）`IS_MMAPPED`位不能置1
```c
if (chunk_is_mmapped (p))
{
    [ ... ]

    munmap_chunk (p);
    return;
}
```

（2）chunk size必须在fast chunk范围内，且必须对齐
```c
if (__glibc_unlikely (size < MINSIZE || !aligned_OK (size)))
{
    errstr = "free(): invalid size";
    goto errout;
}

if ((unsigned long)(size) <= (unsigned long)(get_max_fast ()))
{
    [ ... ]
}
```

（3）2*SIZE_SZ < next chunk size < av->system_mem
```c
if (__builtin_expect (chunk_at_offset (p, size)->size <= 2 * SIZE_SZ, 0)
    || __builtin_expect (chunksize (chunk_at_offset (p, size))
                 >= av->system_mem, 0))
{
    [ ... ]

    errstr = "free(): invalid next size (fast)";
    goto errout;

    [ ... ]
}
```

## 利用步骤
（1）按完整性要求构造一个假fast chunk，其中size大小要能覆盖后面的不可控区域

（2）在假fast chunk的next chunk处，按完整性要求设置size（即next size）

（3）释放假fast chunk，并重新按size大小申请回来

## 利用条件
（1）必须存在这样的内存布局
```
+---------------------+
|                     |
|  Controlled Area 1  |
|                     |
+---------------------+
|                     |
|  Uncontrolled Area  |
|                     |
+---------------------+
|                     |
|  Controlled Area 2  |
|                     |
+---------------------+
```
在`Controlled Area 1`处布置假fast chunk，在`Controlled Area 2`处布置next chunk size。需要注意的是，我们可以通过调试，控制`Controlled Area 1`的chunk size来试图配对栈中现成的符合条件的next chunk size，若能够找到，则可不要求有`Controlled Area 2`

一般来说，这往往是一个栈结构，`Controlled Area 1`可能是子函数的一个可控局部变量，`Controlled Area 2`可能是父函数的一个可控局部变量，而`Uncontroled Area`通常是子函数的返回地址和父函数rbp寄存器，通过覆盖返回地址可以劫持控制流

（2）能控制堆指针指向`Controlled Area 1`处

一般需要结合其他方法完成这一步，比如先泄露`Controlled Area 1`的地址，再寻找覆写堆指针的机会

# House of Force

## 效果
控制指定地址内容

## 利用思想
top chunk切割时，给一个设定好的大小，使得切割后top chunk的头部位于指定地址，再次分配即可分配到指定地址

## 完整性检查
top chunk的size字段必须大于切割块的大小，一般需要通过溢出漏洞将它篡改为-1（即二进制全1）

```c
victim = av->top;
size = chunksize (victim);

// 如果在分割之后，其大小仍然满足 chunk 的最小大小，那么就可以直接进行分割
if ((unsigned long) (size) >= (unsigned long) (nb + MINSIZE))
  {
    // 切割并设置新top chunk
    remainder_size = size - nb;
    remainder = chunk_at_offset (victim, nb);
    av->top = remainder;
    set_head (victim, nb | PREV_INUSE |
              (av != &main_arena ? NON_MAIN_ARENA : 0));
    set_head (remainder, remainder_size | PREV_INUSE);

    check_malloced_chunk (av, victim, nb);
    void *p = chunk2mem (victim);
    alloc_perturb (p, bytes);
    return p;
  }
```

## 利用步骤

（1）分配任意大小（只要没大到需要mmap就行）的堆块

（2）通过溢出漏洞，修改top chunk的size为-1

（3）假设指定地址为`target`，则再分配一个`target - top - 4*SIZE_SZ`大小的堆块，如图
```
+---------------------+ <-- top
|  top chunk header   |
|---------------------|          -------
|                     |             ^
|     top chunk       |             |
|                     |             |
|                     |     target-top-4*SIZE_SZ
|                     |             |
|                     |             |
|                     |             |
         ...                        v
+---------------------+          -------
|    target header    |
|---------------------| <-- target
|                     |
|       target        |
|                     |
+---------------------+
```

（4）再分配一个堆块，即可得到指定地址

## 利用条件

* 分配的堆块大小没有限制（不过要特别注意整数溢出的情形，即输入的大小是有符号整数，但却没有做下界检查）

* 存在溢出漏洞可覆写top chunk头部的size字段

## 副作用

top chunk切割完后，由于此时新的top chunk在指定地址附近，因此在设置新的top chunk头部时，会修改指定地址周围的数据，同样，在随后的malloc也会在设置堆头时修改指定地址周围的数据。若是这些数据很关键，有可能会使程序运行逻辑错误，可能会导致利用不成功

## House of Einherjar